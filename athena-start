#!/bin/sh

# fonte variáveis/funções
. ./function.sh
inst_launch_workaround

PATH=./:$PATH
LOG_DIR="./log"

print_start() {
    #    mais << EOF
    echo "rAthena está iniciando..."
    echo "            (c) 2021 Projeto rAthena"
    echo ""
    echo ""
    echo "verificando..."
    #EOF
}

get_status(){
    PIDFILE=.$1.pid
    if [ -e ${PIDFILE} ]; then
        PSRUN=$(pgrep -F ${PIDFILE})
    fi
    #retorna ${PSRUN} #parece causar um problema em alguns sistemas operacionais
}

# verifica se já está iniciado, inicia e marca no log
start_serv(){ 
    get_status $1
    if [ $2 ]; then # log está ativado ?
        LOGFILE="$LOG_DIR/$1.launch.log"
        LOGRUN="$LOG_DIR/$1.log"
        FIFO="$1_fifo"
        echo "stat_serv, log está ativado"
        echo "Meu arquivo de log=${LOGFILE}"
        if [ -z ${PSRUN} ]; then
            if [ -e ./${FIFO} ]; then rm "$FIFO"; fi
            mkfifo "$FIFO"; tee "$LOGRUN" < "$FIFO" & "./$1" > "$FIFO" 2>&1 & PID=$!
            #"./$1" > >(tee "$LOGRUN") 2>&1 & PID=$! #apenas bash
            echo "$PID" > .$1.pid
            echo "Servidor '$1' iniciado em $(date +"%m-%d-%H:%M-%S")" | tee ${LOGFILE}
        else
            echo "Não é possível iniciar '$1', porque já está executando p${PSRUN}" | tee ${LOGFILE}
        fi
    else
        if [ -z ${PSRUN} ]; then
            ./$1&
            echo "$!" > .$1.pid
            echo "Servidor '$1' iniciado em $(date +"%m-%d-%H:%M-%S")"
        else
            echo "Não é possível iniciar '$1', porque já está executando p${PSRUN}"
        fi
    fi
}

watch_serv(){
    ulimit -Sc unlimited

    # agora verifica status e executa loop
    count=0;
    while true; do
        for i in ${L_SRV} ${C_SRV} ${M_SRV} ${W_SRV}
        do
            LOGFILE="$LOG_DIR/$i.launch.log"
            LOGRUN="$LOG_DIR/$i.log"
            FIFO=$i"_fifo"

            get_status ${i}
            #echo "Echo id de $i é ${PSRUN}"
            if [ -z ${PSRUN} ]; then
                count=$((count+1))
                #echo "fifo=$FIFO"
                echo "servidor '$i' está fora do ar"
                echo "servidor '$i' está fora do ar" >> ${LOGFILE}
                echo "reiniciando servidor em $(date +"%m-%d-%H:%M-%S")"
                echo "reiniciando servidor em $(date +"%m-%d-%H:%M-%S")" >> ${LOGFILE}
                if [ -e $FIFO ]; then rm $FIFO; fi
                mkfifo "$FIFO"; tee "$LOGRUN" < "$FIFO" & "./$i" > "$FIFO" 2>&1 & PID=$!
                echo "$PID" > .$i.pid
                if [ $2 ] && [ $2 -lt $count ]; then break; fi
            fi
        done
        sleep $1
    done
}

restart(){
    $0 stop
    if [ $1 ]; then sleep $1; fi
    for i in ${L_SRV} ${C_SRV} ${M_SRV} ${W_SRV}
    do
        FIFO="$1_fifo"
        while true; do
            get_status ${i}
            if [ ${PSRUN} ]; then echo "'${i}' ainda está executando p${PSRUN} aguardando processo terminar"; sleep 2;
            else 
                if [ -e ./${FIFO} ]; then rm "$FIFO"; fi
                break
            fi
        done
    done
    $0 start
}

case $1 in
    'start')
        print_start
        check_files
        echo "Verificação completa."
        echo "Parece um bom, legal rAthena!"
        if [ "$2" = "--enlog" ]; then
         ENLOG=1
         if [ ! -d "$LOG_DIR" ]; then mkdir -p $LOG_DIR; fi
         echo "Log está ativado em $LOG_DIR"
        else
         echo "Log está desativado"
        fi
        for i in ${L_SRV} ${C_SRV} ${M_SRV} ${W_SRV}
        do
            start_serv $i $ENLOG
        done
        echo "rAthena foi iniciado."
    ;;
    'watch')
        if [ ! -d "$LOG_DIR" ]; then mkdir -p $LOG_DIR; fi
        if [ -z $2 ]; then Restart_count=10; else Restart_count=$2; fi
        if [ -z $3 ]; then Restart_sleep=3; else Restart_sleep=$3; fi
        echo "Monitorando rAthena para restart_count = $Restart_count, restart_sleep = $Restart_sleep"
        for i in ${L_SRV} ${C_SRV} ${M_SRV} ${W_SRV}
        do
            start_serv $i 1
        done
        watch_serv $Restart_count $Restart_sleep
        echo "Monitorando rAthena agora."
    ;;
    'stop')
        for i in ${W_SRV} ${M_SRV} ${C_SRV} ${L_SRV}
        do
            PIDFILE=.${i}.pid
            if [ -e ./${PIDFILE} ]; then
                kill $(cat ${PIDFILE})
                
                while true; do
                    get_status ${i}
                    if [ ${PSRUN} ]; then echo "'${i}' ainda está executando p${PSRUN} aguardando processo terminar"; sleep 2;
                    else
                        break
                    fi
                done
                
                rm ${PIDFILE}
            fi
        done
    ;;
    'restart')
         restart "$@"
    ;;
    'status')
        for i in ${L_SRV} ${C_SRV} ${M_SRV} ${W_SRV}
        do
            get_status ${i}
            if [ ${PSRUN} ]; then echo "'${i}' está executando p${PSRUN}"; else echo "'${i}' parece estar fora do ar"; fi
        done
    ;;
    'val_runonce')
        for i in ${L_SRV} ${C_SRV} ${M_SRV} ${W_SRV}
        do
            valgrind --leak-check=full --show-leak-kinds=all ./$i --run-once > "log/$i.runonce.leak"
        done
    ;;
    'valchk')
        for i in ${L_SRV} ${C_SRV} ${M_SRV} ${W_SRV}
        do
            valgrind --leak-check=full --show-leak-kinds=all ./$i > "log/$i.runonce.leak"
        done
    ;;
    'help')
        case $2 in
            'start')
                echo "sintaxe: 'start {--enlog}'"
                echo "Esta opção iniciará os servidores"
                echo "--enlog gravará toda saída do terminal em um arquivo log/\$servname.log"
            ;;
            'stop')
                echo "Esta opção desligará os servidores"
            ;;
            'restart')
                echo "sintaxe: 'restart {<delay>}'"
                echo "Esta opção aguardará o delay dado e tentará reiniciar os servidores depois"
                echo "Nota: Mesmo se o delay terminar, aguardará até que o pid termine antes de tentar reiniciar os servidores"
            ;;
            'status')
                echo "sintaxe: 'status'"
                echo "Esta opção informará se os servidores estão executando ou não"
                echo "Nota: Esta opção é baseada em PID e requer que você tenha iniciado os servidores com este script também"
                echo "Se não for o caso, use algo como 'ps ax | grep server' para verificar seu status"
            ;;
            'watch')
                echo "sintaxe: 'watch {<restart_interval> <restart_count>}'"
                echo "A opção watch permite reiniciar automaticamente os servidores quando um deles parar"
                echo "<restart_interval> delay em segundos antes de re-verificar se um servidor está fora do ar (padrão 10)"
                echo "<restart_count> quantas vezes os servidores devem ser reiniciados (padrão 3), (-1=indefinidamente)"
            ;;
            'val_runonce')
                echo "sintaxe: 'val_runonce'"
                echo "Esta opção executará valgrind com run-once para verificar os servidores"
            ;;
            'valchk')
                echo "sintaxe: 'valchk'"
                echo "Esta opção executará valgrind com os servidores"
            ;;
            *)
                echo "Por favor, especifique um comando sobre o qual deseja mais informações { start | stop | restart | status | watch }"
                read -p "Digite um comando válido: " readEnterKey
                $0 "help" $readEnterKey
            ;;
        esac
    ;;
    *)
        echo "Uso: athena-start { start | stop | restart | status | watch | help | val_runonce | valchk }"
        read -p "Digite uma opção válida: " readEnterKey
        $0 $readEnterKey
    ;;
esac